<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.00">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

<body bgcolor="#FFFFFF">



<title> The gSOAP DOM Parser (Beta)</title>
    
<h1 align="center">The gSOAP DOM Parser (Beta) </h1>

<h3 align="center">Robert van Engelen <br />Genivia inc. <br />engelen@genivia.com </h3>

<h3 align="center">Jan  5, 2004
<br /><a href="dom.pdf"><font color="#FF0000"><b>[This document is also available in PDF format (black and white only)]</b></font></a></h3>
 <br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; <font color="#0000FF">Introduction</font></a><br />
<a href="#tth_sEc2"
>2&nbsp; <font color="#0000FF">Example 1: Extracting Application Data From an XML Document</font></a><br />
<a href="#tth_sEc3"
>3&nbsp; <font color="#0000FF">Example 2: Embedding Application Data in XML Documents</font></a><br />
<a href="#tth_sEc4"
>4&nbsp; <font color="#0000FF">Example 3: SOAP/XML</font></a><br />
<a href="#tth_sEc5"
>5&nbsp; <font color="#0000FF">Controlling the DOM Parser with Flags</font></a><br />
<a href="#tth_sEc6"
>6&nbsp; <font color="#0000FF">DOM Class</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; <font color="#0000FF">DOM Constructors</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; <font color="#0000FF">DOM Inspection</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; <font color="#0000FF">DOM Iterators</font></a><br />
<a href="#tth_sEc7"
>7&nbsp; <font color="#0000FF">XML Parsing and Streams</font></a><br />
<a href="#tth_sEc8"
>8&nbsp; <font color="#0000FF">Planned Features</font></a><br />
 
</td></tr></table><br></span>
<i>Copyright (C) 2000-2003 Robert A. van Engelen, Genivia inc. All Rights Reserved.</i>


<p>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;<font color="#0000FF">Introduction</font></h2>

<p>
The gSOAP DOM parser is the first DOM parser of its kind that introduces a new
concept, namely the ability to create a DOM structure with both generic DOM
nodes and nodes that consist of native C/C++ application data structures.  The
gSOAP XML parser is integrated in the DOM parser to deserialize native C/C++
application data types from the contents of an XML document to populate the DOM
with nodes that are application-specific.  This unique DOM parsing approach
enables developers to automatically extract application data from any XML
document.  In contrast, other DOM parsers provide a generic DOM tree
representation only.  SAX parsing offers another approach to application-driven
data processing.  While SAX parsing requires application developers to write
the data extraction methods, this DOM parser is fully automatic.

<p>
The DOM parser is a relatively simple parser that supports the XML 1.0
standards including XML namespaces.  It has been specifically designed to
integrate with gSOAP.  The DOM parser can be used with gSOAP to support the
exchange of generic XML documents in SOAP/XML for example.

<p>
The gSOAP compiler-generated XML parsers are validating.  However, this DOM
parser does not attempt to validate documents against schemas.  Additional
features are planned, see Section&nbsp;<a href="#sec:future">8</a>.

<p>
A C++ implementation of the DOM parser is available as well as a pure C
version.  The C++ implementation offers more convenient DOM parsing with
iostream operator overloading, DOM constructors, and DOM tree iterators.

<p>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;<font color="#0000FF">Example 1: Extracting Application Data From an XML Document</font></h2>

<p>
The following example illustrates the gSOAP DOM parser's capabilities to
automatically extract application data from an XML document.

<p>
Suppose our goal is to extract the contents of <tt>&lt;product&#62;</tt> elements from
certain XML documents and store this data in C++ class instances that somehow match the
<tt>&lt;product&#62;</tt> element schema layout.  We assume that the <tt>&lt;product&#62;</tt> element has
the following sub-elements according to its schema: <tt>name</tt> of type <tt>xsd:QName</tt> (qualified
name), <tt>manufacturer</tt> of type <tt>xsd:string</tt>, <tt>SKU</tt> of type
<tt>xsd:int</tt>, <tt>price</tt> of type <tt>xsd:double</tt>, and <tt>description</tt> of
type <tt>xsd:anyType</tt> (i.e.&nbsp;a generic XML document structure).  The
<tt>&lt;product&#62;</tt> element also has an optional attribute <tt>Id</tt> of type
<tt>xsd:ID</tt> to enable cross referencing. The following schema describes the
<tt>&lt;product&#62;</tt> element and type, where the namespace of <tt>&lt;product&#62;</tt> is assumed to
be <tt>http://domain/schemas/product.xsd</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;schema targetNamespace="http://domain/schemas/product.xsd" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://domain/schemas/product.xsd" <br />
&nbsp;&nbsp;&nbsp;xmlns="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;elementFormDefault="unqualified" <br />
&nbsp;&nbsp;&nbsp;attributeFormDefault="unqualified"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;element name="product" type="ns:product"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;complexType name="product"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sequence&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="name" type="xsd:QName" minOccurs="1" maxOccurs="1" nillable="true"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="manufacturer" type="xsd:string" minOccurs="0" maxOccurs="1" nillable="true"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="SKU" type="xsd:int" minOccurs="1" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="price" type="xsd:double" minOccurs="1" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="description" type="xsd:anyType" minOccurs="0" maxOccurs="1" nillable="true"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/sequence&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute name="Id" type="xsd:ID" use=&#246;ptional"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&lt;/schema&#62;
</td></tr></table><br></tt>
The class <i>ns__product</i> declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#import "dom++.h" // import DOM definitions (defines xsd:anyType) <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*_xsd__QName; // define xsd:QName <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*_xsd__string; // define xsd:string <br />
<b>typedef</b>&nbsp;<b>int</b>&nbsp;_xsd__int; // define xsd:int <br />
<b>typedef</b>&nbsp;<b>double</b>&nbsp;_xsd__double; // define xsd:double <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*_xsd__ID; // define xsd:ID <br />
//gsoap ns schema namespace: http://domain/schemas/product.xsd <br />
<b>class</b>&nbsp;ns__product <br />
{ <b>public</b>: <br />
&nbsp;&nbsp;&nbsp;_xsd__QName name; <br />
&nbsp;&nbsp;&nbsp;_xsd__string manufacturer 0; <br />
&nbsp;&nbsp;&nbsp;_xsd__int SKU; <br />
&nbsp;&nbsp;&nbsp;_xsd__double price; <br />
&nbsp;&nbsp;&nbsp;xsd__anyType *description 0; <br />
&nbsp;&nbsp;&nbsp;@_xsd__ID Id 0; <br />
&nbsp;&nbsp;&nbsp;ns__product(); <br />
&nbsp;&nbsp;&nbsp;~ns__product(); <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;unlink(<b>struct</b>&nbsp;soap *soap); <br />
};
</td></tr></table><br></i>
The class declaration can be obtained with the WSDL importer from a WSDL with a
schema for the <tt>&lt;product&#62;</tt> type (we plan to enhance the WSDL importer to
support the parsing of schemas without WSDL).

<p>
The <i>ns__product</i> class reflects the XML schema layout and properties of
the <tt>&lt;product&#62;</tt> element and type.  The built-in schema types
<tt>xsd:QName</tt>, <tt>xsd:string</tt>, etc., are declared in gSOAP with
<i><b>typedef</b></i>s.

<p>
We invoke the gSOAP compiler from the command line to generate the <i>ns__
product</i> class (de)serializers
(we assume that the class is declared in <i>product.h</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 product.h</i>
</td></tr></table><br></span>
This produces the files <i>soapStub.h</i>, <i>soapH.h</i>, and <i>soapC.cpp</i>
(among other files) with the <i>ns__product</i> (de)serializers.  These files are
needed to build our customized DOM parser.  In addition, the file <i>ns.xsd</i>
is generated which contains the XML schema of <tt>ns:product</tt>.  This may come
in handy.

<p>
Suppose we have an XML document that contains one or more <tt>&lt;product&#62;</tt>
elements (within the appropriate XML namespace) and we want to extract these
elements from the document in an application-specific format, i.e.&nbsp;as <i>ns__
product</i> class instances.  The following code parses the document from the standard
input stream and then iterates over the DOM thereby
printing the price of the deserialized <i>ns__product</i>
instances:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; iostream.h &gt;  <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_dom_element document(soap_new()); // create a DOM with a new soap environment <br />
&nbsp;&nbsp;&nbsp;soap_set_imode(document.soap, SOAP_DOM_NODE); // DOM w/ application data nodes <br />
&nbsp;&nbsp;&nbsp;cin <tt>&gt;&gt;</tt> document; // parse XML <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(soap_dom_iterator walker = document.find(SOAP_TYPE_ns__product); walker != document.end(); ++walker) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ns__product *product = (ns__product*)(*walker).node; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <tt>&lt;&lt;</tt> product<tt>-&gt;</tt>name <tt>&lt;&lt;</tt> " price=" <tt>&lt;&lt;</tt> product<tt>-&gt;</tt>price <tt>&lt;&lt;</tt> endl; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_destroy(document.soap); // delete deserialized DOM parts <br />
&nbsp;&nbsp;&nbsp;soap_end(document.soap); // clean up <br />
&nbsp;&nbsp;&nbsp;soap_done(document.soap); // detach soap environment <br />
&nbsp;&nbsp;&nbsp;free(document.soap); // free soap environment <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "http://domain/schemas/product.xsd"}, // the namespace of products <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
The code is compiled and linked with <i>dom++.cpp</i>, <i>stdsoap2.cpp</i>, and <i>soapC.cpp</i>.
The input-mode flag <i>SOAP_DOM_NODE</i> is used to force the DOM parser to
use application-specific data type deserializers to parse the DOM and populate the nodes
with C/C++ application types.  (Note: when
no flag is used, an appropriate deserializer MAY be used by gSOAP when an
element contains an <tt>id</tt> attribute and gSOAP can determine the type from
the <tt>id</tt> attribute reference and/or the <tt>xsi:type</tt> attribute of an
element.)  When we invoked the gSOAP compiler from the command line, it
generated a deserializer for the <i>ns__product</i> class which is used to
populate the DOM with instances.  The type identifier of this class is
<i>SOAP_TYPE_ns__product</i> (gSOAP generates type identifiers of the form
<i>SOAP_TYPE__<i>x</i></i> where <i>x</i> is the name of a type).  The forward
iterator <i>document.find(SOAP_TYPE_ns__product)</i> traverses the DOM and
selects the <i>ns__product</i> nodes which we access with
<i>(ns__product*)(*walker).node</i>.

<p>
As an example suppose we want to print the price of the products in the following XML document:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;document <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://domain/schemas/product.xsd" <br />
&nbsp;&nbsp;&nbsp;&lt;ns:product Id="Z"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&#62;ns:Zoe&lt;/name&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;manufacturer&#62;Sesame Street&lt;/manufacturer&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SKU&#62;123&lt;/SKU&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;price&#62;9.95&lt;/price&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/ns:product&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;m:product xmlns:m="http://domain/schemas/product.xsd"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&#62;m:Pluto&lt;/name&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SKU&#62;567&lt;/SKU&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;price&#62;19.95&lt;/price&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&#62;This &lt;i&#62;lovely&lt;/i&#62; doll is a &lt;b&#62;every&lt;/b&#62; child's wish&lt;/description&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;x:value xmlns:x="http://domain/schemas/value.xsd"&#62;12&lt;/x:value&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/m:product&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;product xmlns="http://otherdomain"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&#62;Gadget&lt;/name&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;content xsi:type=&#255;:value" xmlns:y="http://domain/schemas/value.xsd"&#62;3&lt;content&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/product&#62; <br />
&lt;/document&#62;
</td></tr></table><br></tt>
Note that the last product <tt>&lt;product xmlns="http://otherdomain"&#62;</tt> is not in the namespace of our products.

<p>
The program fragment shown above parses the document and then prints:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
ns:Zoe price=9.95 <br />
ns:Pluto price=19.95
</td></tr></table><br></span>
Note that the QName <tt>m:Pluto</tt> is in our namespace and therefore the
namespace prefix <tt>ns</tt> replaces <tt>m</tt> in the document.  Also note that
certain elements are optional (<tt>minOccurs="0"</tt> in the schema and the
<i>0</i>'s used in the class declaration).

<p>
The deserialized data of the DOM is removed with the
<i>soap_destroy()</i> and <i>soap_end()</i> calls.  To retain class instances
and their data, you have to unlink the data references from gSOAP's
deallocation chain with <i>soap_unlink(soap, <i>pointer</i>)</i>, where <i>
pointer</i> points to a class instance.  Also the pointer-based data members need
to be unlinked if you want to preserve their values.  You can do this by adding
an appropriate method to the class which calls <i>soap_unlink(soap, this)</i>
and also calls <i>soap_unlink()</i> on all its pointer-based data members.  For
example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
ns__product::unlink(<b>struct</b>&nbsp;soap *soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_unlink(soap, <b>this</b>); <br />
&nbsp;&nbsp;&nbsp;soap_unlink(soap, name); <br />
&nbsp;&nbsp;&nbsp;soap_unlink(soap, manufacturer); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(description) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description<tt>-&gt;</tt>unlink(); <br />
&nbsp;&nbsp;&nbsp;soap_unlink(soap, Id); <br />
}
</td></tr></table><br></i>
To deserialize primitive type values, you can use a typedef to define the element name and type without or without a namespace qualifier.  The following gSOAP header file declares a <tt>&lt;value&#62;</tt> element and type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#import "dom++.h" <br />
<b>typedef</b>&nbsp;<b>int</b>&nbsp;v__value;
</td></tr></table><br></i>
This assumes that all <tt>&lt;v:value&#62;</tt> elements in a document are integer valued.  This header file is processed with the gSOAP compiler to produce the (de)serializers.

<p>
The code fragment below prints the integer contents of the <tt>&lt;v:value&#62;</tt> elements of a document:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; iostream.h &gt;  <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_dom_element document(soap_new()); // create a DOM with a new soap environment <br />
&nbsp;&nbsp;&nbsp;soap_set_imode(document.soap, SOAP_DOM_NODE); // DOM w/ application data <br />
&nbsp;&nbsp;&nbsp;cin <tt>&gt;&gt;</tt> document; // parse XML <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(soap_dom_iterator walker = document.find(SOAP_TYPE_v__value); walker != document.end(); ++walker) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <tt>&lt;&lt;</tt> *(v__value*)(*walker).node <tt>&lt;&lt;</tt> endl; <br />
&nbsp;&nbsp;&nbsp;soap_destroy(document.soap); // delete DOM <br />
&nbsp;&nbsp;&nbsp;soap_end(document.soap); // clean up <br />
&nbsp;&nbsp;&nbsp;soap_done(document.soap); // detach soap environment <br />
&nbsp;&nbsp;&nbsp;free(document.soap); // free soap environment <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "http://domain/schemas/product.xsd"}, // the namespace of products <br />
&nbsp;&nbsp;&nbsp;{"v", "http://domain/schemas/value.xsd}, // the namespace of values <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
The program fragment parses the example XML document shown in this section and then prints:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
12 <br />
3
</td></tr></table><br></span>
The first value was retrieved from the <tt>&lt;x:value&#62;</tt> element (with matching namespace) and the second value was retrieved from the
<tt>&lt;content xsi:type=&#255;:value"&#62;</tt> element in the third product element, because the type <tt>y:value</tt> matches the <tt>v:value</tt> schema type.

<p>
To create a DOM that does not contain application-specific data structures is
simple.  Consider for example the following code that parses a DOM from the
standard input stream and then copies it to the standard output stream:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
soap_dom_element document(soap_new()); // create a DOM with a new soap environment <br />
soap_set_imode(document.soap, SOAP_DOM_TREE); // DOM tree w/o application data <br />
cin <tt>&gt;&gt;</tt> document; // parse <br />
cout <tt>&lt;&lt;</tt> document; // print it <br />
soap_destroy(document.soap); // delete entire DOM <br />
soap_end(document.soap); // clean up <br />
soap_done(document.soap); // detach the soap environment <br />
free(document.soap); // free the soap environment <br />
...
</td></tr></table><br></i>
In this example the input-mode flag <i>SOAP_DOM_TREE</i> forces the parser to
construct a DOM only and ignore any application-specific data elements in the
XML document.

<p>
The leading underscore (<i>_</i>) in the names of the <i>_xsd__</i> types
defined in the header file has a special meaning.  When names of C/C++ types
(i.e.&nbsp;<i><b>typedef</b></i>s, <i><b>struct</b></i>s, <i><b>class</b></i>es, <i><b>enum</b></i>s) are
defined with a leading underscore, the XML elements that are defined with these
types will not carry the <i>xsi:type</i> attribute in the XML document.  That
is, it makes the XML document untyped.  The gSOAP DOM output will therefore
omit the <i>xsi:type</i> attributes in the XML document.

<p>
You can eliminate the <i>ns__</i> namespace prefix from the <i>ns__product</i>
class, but doing so will force the XML parser to deserialize all

<p>
<tt>&lt;product&#62;</tt> elements from an XML document without namespace validation.

<p>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;<font color="#0000FF">Example 2: Embedding Application Data in XML Documents</font></h2>

<p>
The following example illustrates the embedding of application data in XML
documents.  We use the <i>ns__product</i> class of Example 1 to create an XML
document with a <tt>&lt;product&#62;</tt> element.  The following code constructs an instance
and binds it to the appropriate place in the DOM representation of the XML document:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; iostream.h &gt;  <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;ns__product product; <br />
&nbsp;&nbsp;&nbsp;product.name = "ns:Zoe"; <br />
&nbsp;&nbsp;&nbsp;product.manufacturer = "Sesame Street"; <br />
&nbsp;&nbsp;&nbsp;product.SKU = 123; <br />
&nbsp;&nbsp;&nbsp;product.price = 9.95; <br />
&nbsp;&nbsp;&nbsp;product.description = NULL; <br />
&nbsp;&nbsp;&nbsp;product.Id = "Z"; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap = soap_new(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element document(soap_new(), "urn:test", "myDocument"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute myAttribute(document.soap, NULL, "myAttribute", "Y"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element myElement(document.soap, NULL, "myElement", "X"); <br />
&nbsp;&nbsp;&nbsp;document.add(myAttribute); <br />
&nbsp;&nbsp;&nbsp;document.add(myElement); <br />
&nbsp;&nbsp;&nbsp;document.add("http://domain/schemas/product.xsd", "product", product, SOAP_TYPE_ns__product); <br />
&nbsp;&nbsp;&nbsp;cout <tt>&lt;&lt;</tt> document; <br />
&nbsp;&nbsp;&nbsp;soap_destroy(document.soap); // delete DOM <br />
&nbsp;&nbsp;&nbsp;soap_end(document.soap); // clean up <br />
&nbsp;&nbsp;&nbsp;soap_done(document.soap); // detach soap environment <br />
&nbsp;&nbsp;&nbsp;free(document.soap); // free soap environment <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "http://domain/schemas/product.xsd"}, // the namespace of products <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
}
</td></tr></table><br></i>
The code is linked with <i>dom++.cpp</i>, <i>stdsoap2.cpp</i>, and <i>soapC.cpp</i>.
The program prints:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-DOM0:myDocument <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://domain/schemas/product.xsd" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-DOM0="urn:test" <br />
&nbsp;&nbsp;&nbsp;myAttribute="Y"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;myElement&#62;X&lt;/myElement&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;ns:product Id="Z"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&#62;ns:Zoe&#171;/name&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;manufacturer&#62;Sesame Street&lt;/manufacturer&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SKU&#62;123&lt;/SKU&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;price&#62;9.95&lt;/price&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/ns:product&#62; <br />
&lt;/SOAP-DOM0:myDocument&#62;
</td></tr></table><br></tt>
The root of the DOM is <tt>&lt;myDocument&#62;</tt> with namespace <tt>urn:test</tt>. The
root has two sub elements: <tt>&lt;myElement&#62;</tt> and <tt>&lt;product&#62;</tt> with namespace
<tt>http://domain/schemas/product.xsd</tt>. It also has an attribute
<tt>myAttribute="Y"</tt>.

<p>
The global namespace mapping table <i>namespaces[]</i> contains the
namespace bindings that we intend to use in our application.  That is, it should contain
the standard namespaces for SOAP/XML and XML schemas.

<p>
You can also create non-global tables and assign them to the gSOAP environment when the need arises:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap *soap = soap_new(); <br />
soap<tt>-&gt;</tt>namespaces = myNamespaces;
</td></tr></table><br></i>
where <i>myNamespaces</i> should be a namespace mapping table.

<p>
To eliminate the use of these tables, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap *soap = soap_new(); <br />
soap<tt>-&gt;</tt>namespaces = NULL;
</td></tr></table><br></i>
And compile with <i>-DWITH_NONAMESPACES</i>.  However, doing so will change the
behavior of the DOM parser when parsing documents.  Firstly, <tt>xsi:type</tt>
information is ignored, so application data cannot be retrieved from elements
with <tt>xsi:types</tt>.  In addition, QNames cannot be handled.  Normally the
parser maps QNames to the appropriate namespace prefixes where the mapping is
defined in the table. Without the table with bindings to resolve the QName
values are of the form <tt>"namespaceURI":name</tt>.

<p>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;<font color="#0000FF">Example 3: SOAP/XML</font></h2>

<p>
The gSOAP DOM parser can be used to implement SOAP/XML clients and services
that support SOAP document encoding.  The following gSOAP header file uses the
<i>xsd__anyType</i> (the external DOM XML serializer) to exchange generic XML
documents as SOAP/XML service parameters:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#import "dom++.h" <br />
//gsoap ns service name: docu <br />
//gsoap ns service namespace: http://domain/services/docu.wsdl <br />
//gsoap ns service encoding: literal <br />
//gsoap ns schema namespace: urn:docu <br />
<b>int</b>&nbsp;ns__docuXchange(xsd__anyType in, xsd__anyType *out);
</td></tr></table><br></i>
The client-side and server-side codes are straightforward implementations of
the usual gSOAP proxy/stub and skeleton implementations for SOAP/XML Web
services (not shown).

<p>
The following example illustrates the use of the DOM parser to construct an entire SOAP/XML message to interact with the XMethods Delayed Stock Quote Service.  The gSOAP header file imports the DOM definitions and declares a <tt>xsd__float</tt> type which we will use to extract float values from a SOAP/XML response:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#import "dom++.h" <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float;
</td></tr></table><br></i>
The code is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; iostream.h &gt;  <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap = soap_new(); <br />
&nbsp;&nbsp;&nbsp;soap_set_imode(soap, SOAP_DOM_NODE); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element envelope(soap, "http://schemas.xmlsoap.org/soap/envelope/", &#203;nvelope"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element body(soap, "http://schemas.xmlsoap.org/soap/envelope/", "Body"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute encodingStyle(soap, NULL, "encodingStyle", "http://schemas.xmlsoap.org/soap/encoding/"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element request(soap, "urn:xmethods-delayed-quotes", "getQuote"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element symbol(soap, NULL, "symbol", "IBM"); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element response(soap); <br />
&nbsp;&nbsp;&nbsp;envelope.add(body); <br />
&nbsp;&nbsp;&nbsp;body.add(encodingStyle); <br />
&nbsp;&nbsp;&nbsp;body.add(request); <br />
&nbsp;&nbsp;&nbsp;request.add(symbol); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_connect(soap, "http://services.xmethods.net/soap", "") // = SOAP_OK when successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  |  soap_put_xsd__anyType(soap, &amp;envelope, NULL, NULL) // = SOAP_OK when successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  |  soap_end_send(soap) // = SOAP_OK when successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  |  soap_begin_recv(soap) // = SOAP_OK when successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  |  !soap_get_xsd__anyType(soap, &amp;response, NULL, NULL) // = NULL when not successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  |  soap_end_recv(soap) // = SOAP_OK when successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  |  soap_closesock(soap)) // = SOAP_OK when successful <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <tt>&lt;&lt;</tt> response <tt>&lt;&lt;</tt> endl; <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(soap_dom_iterator walker = response.find(SOAP_TYPE_xsd__float); walker != response.end(); ++walker) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <tt>&lt;&lt;</tt> "Quote = " <tt>&lt;&lt;</tt> *(xsd__float*)(*walker).node <tt>&lt;&lt;</tt> endl; <br />
&nbsp;&nbsp;&nbsp;soap_destroy(soap); <br />
&nbsp;&nbsp;&nbsp;soap_end(soap); <br />
&nbsp;&nbsp;&nbsp;soap_done(soap); <br />
&nbsp;&nbsp;&nbsp;free(soap); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
Compile the code and link it with <i>dom++.cpp</i>, <i>stdsoap2.cpp</i>, and <i>soapC.cpp</i>.
The program prints the SOAP/XML response and a floating point value.

<p>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;<font color="#0000FF">Controlling the DOM Parser with Flags</font></h2>

<p>
The following input-mode flags (<i>soap_imode()</i> flags) can be used to control the DOM parser:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Flag</b></font> </td><td width="401"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>SOAP_DOM_TREE</i> </td><td width="401">parse XML as a DOM only w/o embedding application data nodes </td></tr>
<tr><td><i>SOAP_DOM_NODE</i> </td><td width="401">parse XML as a DOM and attempt to embed application data nodes when possible </td></tr>
<tr><td><i>SOAP_C_UTFSTRING</i> </td><td width="401">parse XML cdata in UTF-8 form into the <i>xsd__anyType.data</i> string field </td></tr></table>

</td></tr></table><br></span>
The flags are disabled by default. This means that application data nodes are
embedded in the DOM only when necessary (this requirement is applicable to
SOAP/XML messages that combine the gSOAP SOAP/XML with the DOM) and cdata is
parsed into the <i>xsd__anyType.wide</i> field.

<p>
The following output-mode flags (<i>soap_omode()</i> flags) can be used to control the DOM parser output:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Flag</b></font> </td><td width="401"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>SOAP_XML_CANONICAL</i> </td><td width="401">produce canonical XML </td></tr>
<tr><td><i>SOAP_ENC_ZLIB</i> </td><td width="401">compress output with Zlib (see gSOAP documentation) </td></tr>
<tr><td><i>SOAP_C_UTFSTRING</i> </td><td width="401">input/output <i>data</i> string field encoded in UTF8 </td></tr></table>

</td></tr></table><br></span>

<p>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;<font color="#0000FF">DOM Class</font></h2>

<p>
The DOM class definition (current beta form).
Note: <i>xsd__anyType</i> is an alias of <i>soap_dom_element</i>.  It defines the serializers of the DOM in gSOAP.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap_dom_element <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_dom_element *next;		// next element (sibling) in sequence (not used at the document root) <br />
&nbsp;&nbsp;&nbsp;soap_dom_element *prnt;		// parent node <br />
&nbsp;&nbsp;&nbsp;soap_dom_element *elts;		// optional element children (data, wide, node must be NULL) <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute *atts;		// optional element attributes <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr;		// optional namespace name string (URI) <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name;			// element name with optional prefix <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*data;			// optional element CDATA value <br />
&nbsp;&nbsp;&nbsp;wchar_t *wide;			// optional element CDATA value (wide char string) <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;type;			// optional type of data pointed to (SOAP_TYPE_X) <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;*node;			// and the optional pointer to serializable data node <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap;		// gSOAP soap struct that manages this node <br />
&nbsp;&nbsp;&nbsp;soap_dom_element(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element(struct soap *soap); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element(struct soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element(struct soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>*data); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element(struct soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>void</b>&nbsp;*node, <b>int</b>&nbsp;type); <br />
&nbsp;&nbsp;&nbsp;~soap_dom_element(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;set(<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;set(<b>const</b>&nbsp;<b>char</b>&nbsp;*data); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;set(<b>void</b>&nbsp;*node, <b>int</b>&nbsp;type);	 <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;add(soap_dom_element *elt); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;add(soap_dom_element &amp;elt); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;add(soap_dom_attribute *att); <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;add(soap_dom_attribute &amp;att); <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator begin(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator end(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator find(<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name); <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator find(<b>int</b>&nbsp;type); <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;unlink(); <br />
}; <br />
<b>struct</b>&nbsp;soap_dom_attribute <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute *next;		// next attribute in sequence <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr;			// optional attribute namespace name string (URI) <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name;			// attribute name <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*data;			// optional attribute CDATA value <br />
&nbsp;&nbsp;&nbsp;wchar_t *wide;			// optional attribute CDATA value (not used) <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap;			// gSOAP soap struct that manages this instance <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute(<b>struct</b>&nbsp;soap *soap); <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*data); <br />
&nbsp;&nbsp;&nbsp;~soap_dom_attribute(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute &amp;set(<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name); <br />
&nbsp;&nbsp;&nbsp;soap_dom_attribute &amp;set(<b>const</b>&nbsp;<b>char</b>&nbsp;*data); <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;unlink(); <br />
}; <br />
<b>class</b>&nbsp;soap_dom_iterator <br />
{ <b>public</b>: <br />
&nbsp;&nbsp;&nbsp;soap_dom_element *elt; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;type; <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator(); <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator(soap_dom_element *elt); <br />
&nbsp;&nbsp;&nbsp;~soap_dom_iterator(); <br />
&nbsp;&nbsp;&nbsp;<b>bool</b>&nbsp;<b>operator</b>==(<b>const</b>&nbsp;soap_dom_iterator &amp;iter) <b>const</b>; <br />
&nbsp;&nbsp;&nbsp;<b>bool</b>&nbsp;<b>operator</b>!=(<b>const</b>&nbsp;soap_dom_iterator &amp;iter) <b>const</b>; <br />
&nbsp;&nbsp;&nbsp;soap_dom_element &amp;<b>operator</b>*() <b>const</b>; <br />
&nbsp;&nbsp;&nbsp;soap_dom_iterator &amp;<b>operator</b>++(); <br />
};
</td></tr></table><br></i>

<p>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;<font color="#0000FF">DOM Constructors</font></h3>

<p>
Note: <i>xsd__anyType</i> is an alias of <i>soap_dom_element</i>.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b><i>soap_dom_element</i> constructors</b></font> </td></tr>
<tr><td width="602"><i>soap_dom_element(<b>struct</b>&nbsp;soap *soap)</i> </td></tr>
<tr><td width="602">Creates a document DOM node and binds it to a gSOAP environment for memory management and I/O </td></tr>
<tr><td width="602"><i>soap_dom_element(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name)</i> </td></tr>
<tr><td width="602">Creates a document DOM node with namespace URI and element name </td></tr>
<tr><td width="602"><i>soap_dom_element(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*data)</i> </td></tr>
<tr><td width="602">Creates a document DOM node with namespace URI, element name, and element content </td></tr>
<tr><td width="602"><i>soap_dom_element(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>void</b>&nbsp;*node, <b>int</b>&nbsp;type)</i> </td></tr>
<tr><td width="602">Creates a document DOM node containing an application-specific data structure </td></tr></table>

</td></tr></table><br></span>

<p>
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b><i>soap_dom_attribute</i> constructors</b></font> </td></tr>
<tr><td width="602"><i>soap_dom_attribute(<b>struct</b>&nbsp;soap *soap)</i> </td></tr>
<tr><td width="602">Creates a DOM node attribute and binds it to a gSOAP environment for memory management and I/O </td></tr>
<tr><td width="602"><i>soap_dom_attribute(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*data)</i> </td></tr>
<tr><td width="602">Creates a DOM node attribute with namespace URI, name, and content </td></tr></table>

</td></tr></table><br></span>

<p>
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b><i>soap_dom_element</i> methods</b></font> </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;set(<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name)</i> </td></tr>
<tr><td width="602">Set the namespace and name of a DOM node </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;set(<b>const</b>&nbsp;<b>char</b>&nbsp;*data)</i> </td></tr>
<tr><td width="602">Set the DOM node element content </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;set(<b>void</b>&nbsp;*node, <b>int</b>&nbsp;type)</i> </td></tr>
<tr><td width="602">Set the DOM node to contain an application-specific data structure </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;add(soap_dom_element *elt)</i> </td></tr>
<tr><td width="602">Add a new sub element (child) to the DOM node </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;add(soap_dom_element &amp;elt)</i> </td></tr>
<tr><td width="602">Add a new sub element (child) to the DOM node </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;add(soap_dom_attribute *att)</i> </td></tr>
<tr><td width="602">Add a new element attribute to the DOM node </td></tr>
<tr><td width="602"><i>soap_dom_element &amp;add(soap_dom_attribute &amp;att)</i> </td></tr>
<tr><td width="602">Add a new element attribute to the DOM node </td></tr>
<tr><td width="602"><i><b>void</b>&nbsp;unlink()</i> </td></tr>
<tr><td width="602">Unlink the DOM node, attributes, children, and content from the gSOAP deallocation chain </td></tr></table>

</td></tr></table><br></span>

<p>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;<font color="#0000FF">DOM Inspection</font></h3>

<p>
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b><i>soap_dom_element</i> data members</b></font> </td></tr>
<tr><td width="602"><i><b>const</b>&nbsp;<b>char</b>&nbsp;*nstr</i> </td></tr>
<tr><td width="602">Namespace name string (URI) </td></tr>
<tr><td width="602"><i><b>char</b>&nbsp;*name</i> </td></tr>
<tr><td width="602">Element name with optional prefix </td></tr>
<tr><td width="602"><i><b>char</b>&nbsp;*data</i> </td></tr>
<tr><td width="602">Element CDATA content value (DOM output only, set by parser only with SOAP_C_UTFSTRING flag set) </td></tr>
<tr><td width="602"><i>wchar_t *wide</i> </td></tr>
<tr><td width="602">Element CDATA content value (wide char string) </td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;type</i> </td></tr>
<tr><td width="602">The type (<i>SOAP_TYPE_<i>x</i></i> identifier) of the data pointed to by <i>node</i> </td></tr>
<tr><td width="602"><i><b>void</b>&nbsp;*node</i>
Pointer to serializable data type node </td></tr>
<tr><td width="602"><i>soap_dom_element *elts</i> </td></tr>
<tr><td width="602">Children of a node (data, wide, and node must be NULL) </td></tr>
<tr><td width="602"><i>soap_dom_attribute *atts</i> </td></tr>
<tr><td width="602">Element node attributes </td></tr></table>

</td></tr></table><br></span>
Note: all data members are public. The class provides setter methods, but no
getter methods. DOM node values can be inspected directly.  This access policy
may change depending on user feedback on this beta release with regard to
getter methods versus direct access.

<p>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;<font color="#0000FF">DOM Iterators</font></h3>

<p>
The <i>find</i> method returns a DOM iterator.  The iterators of <i>xsd__anyType</i> are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b><i>soap_dom_element</i> iterator methods</b></font> </td></tr>
<tr><td width="602"><i>soap_dom_iterator begin()</i> </td></tr>
<tr><td width="602">Iterates over all DOM nodes </td></tr>
<tr><td width="602"><i>soap_dom_iterator end()</i> </td></tr>
<tr><td width="602">Points past last node (empty iterator) </td></tr>
<tr><td width="602"><i>soap_dom_iterator find(<b>const</b>&nbsp;<b>char</b>&nbsp;*nstr, <b>const</b>&nbsp;<b>char</b>&nbsp;*name)</i> </td></tr>
<tr><td width="602">Iterates over nodes with namespacec name (URI) and element tag name.  The
namespace and element tag names are patterns that may include the wilcards '*' (multi-character wildcard)
and '-' (single-character wildcard). </td></tr>
<tr><td width="602"><i>soap_dom_iterator find(<b>int</b>&nbsp;type)</i>  </td></tr>
<tr><td width="602">Iterates over nodes with type (a <i>SOAP_TYPE_<i>x</i></i> type identifier) </td></tr></table>

</td></tr></table><br></span>
All iterators are forward iterators that traverse the tree in order.

<p>
The <i>nstr</i> and <i>name</i> parameters of the <i>find</i> method specify the
namespace name (URI) and XML element tag name of the DOM nodes, respectively.
These parameters MAY contain wildcards: an asterisk denotes a multi-character
wildcard and a dash denotes a single character wildcard. For example,
<i>document.find("*", "product")</i> iterates over all <tt>&lt;product&#62;</tt> nodes in
any namespace.

<p>
A <i>type</i> parameter is a type identifier <i>SOAP_TYPE_<i>x</i></i>, where
<i>x</i> is the name of the type.  The type MUST have a definition in a gSOAP
header file, so the gSOAP compiler can generate its (de)serializers and the
type identifier.  The type <i>x</i> is the name of a type defined with a
<i><b>typedef</b></i>, <i><b>struct</b></i>, <i><b>class</b></i>, or <i><b>enum</b></i>, or it is the name
of a primitive type such as <i>int</i>.

<p>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;<font color="#0000FF">XML Parsing and Streams</font></h2>

<p>
A DOM can be parsed from a stream using the <tt>&gt;&gt;</tt> stream operator. A DOM
can be written to a stream using the <tt>&lt;&lt;</tt> stream operator. It is important
that the DOM is bound to a gSOAP environment (soap struct) to handle the memory
management and I/O operations. The binding also enables the use of various
gSOAP settings to control XML parsing and generation such as compression.

<p>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;<font color="#0000FF">Planned Features</font></h2><a name="sec:future">
</a>

<p>
The DOM parser is a beta release. Future additions will include:

<ul><p>
<li> Support for DOM level-2 (NodeWalker, NodeIterator, and NodeFilter)
[http://www.w3.org/TR/DOM-Level-2-Traversal-Range/traversal.html#Iterator-overview]</li>
<p>
<li> XPath access (?)</li>
<p>
<li> Handle mixed element content differently (?) Currently stores mixed content in string form.</li>
<p>
<li> ...</li>
</ul>

<p>
</body>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.00.<br />On  5 Jan 2004, 23:41.</small>
</html>
